/* Generated By:JJTree: Do not edit this line. FormPreprocessor.jj */
options {
ERROR_REPORTING=true;
STATIC=true;
USER_CHAR_STREAM=false;
OTHER_AMBIGUITY_CHECK=1;
BUILD_TOKEN_MANAGER=true;
DEBUG_TOKEN_MANAGER=false;
DEBUG_LOOKAHEAD=false;
USER_TOKEN_MANAGER=false;
LOOKAHEAD=1;
IGNORE_CASE=false;
FORCE_LA_CHECK=false;
SANITY_CHECK=true;
JAVA_UNICODE_ESCAPE=true;
CHOICE_AMBIGUITY_CHECK=2;
BUILD_PARSER=true;
DEBUG_PARSER=false;
COMMON_TOKEN_ACTION=false;
UNICODE_INPUT=false;
}

PARSER_BEGIN(FormPreprocessor)
package com.chimu.formTools.preprocessor;
import java.io.*;
import java.util.Vector;

/**
The FormPreprocessor parses a java source file and annotates it with FORM
relevant information.  Currently this information includes 'unstubbing'
objects when referenced and FORM specific method to initialize and extract
state information.

<P>The FormPreprocessor is a command line utility.
Execute 'java com.chimu.formTools.preprocessor.FormPreprocessor' for the
most current usage information.  The following is an example:

<PRE>
* FORM Preprocessor Version 1.7
* Usage:
*     FormPreprocessor [options] (file | directory)*
* or
*     java com.chimu.formTools.preprocessor.FormPreprocessor ...
*
* Options:
*     -s  <directory>   Source directory
*     -d  <directory>   Destination directory
*     -sx <extension>   Source file extension
*     -dx <extension>   Destination file extension
*
*     -slotConstants <visibility>? Generate constants for slot names
*                           Visibility: public, protected, package, private
*
*     -haveImports      Do not generate full class path names
*     -getters          Generate getter functors for instance variables
*     -setters          Generate setter functors for instance variables
*
*     -formInfo         Generate a FormInfo file
*     -builder <class>  Use <class> to generate the FormInfo file
*
*     -safe             Do not overwrite existing destination or backup files
*     -f                Force operation even if destination or backup exist
</PRE>
**/

public class FormPreprocessor{

    static public FormPreprocessor parser = null;
    static public boolean overwrite = true;
    static public boolean force = true;
    static public boolean force2 = false;  //Second level of forcefulness ... lose originals
    static public String destinationDirectory = null;
    static public String sourceDirectory = null;
    static public String defaultExtension = null;
    static public String sourceExtension = null;
    static public String destinationExtension = null;

    static public String infoBuilderClassName = null;

    static public boolean wantGetters = false;
    static public boolean wantSetters = false;
    static public boolean wantMarkDirties = false;  //put in markDirties?
    static public int constructorType = 0;
    static public boolean haveImports = false;
    static public boolean formConstructor = true;
    static public boolean generateFormInfo = false;

    static public boolean useSlotConstants = false;
    static public String slotConstantVisibility = "protected";

    static public String versionString = "1.8";

    static public SourceConverterPrinter currentOstr;

    static String[] getArguments(String[] args) {
        Vector files = new Vector();
        for (int i = 0; i < args.length; i++) {
            String arg = args[i].toLowerCase();
            if (arg.equals("-d")) {
                if (i < args.length) {
                    destinationDirectory = args[++i];
                    overwrite = false;
                } else {
                    System.out.println("No destination directory for -d.");
                    System.exit(1);
                };
            } else if (arg.equals("-slotconstants")) {
                if (i < args.length) {
                    String nextArgument = args[i+1].toLowerCase();
                    if (nextArgument.equals("public")) {
                        slotConstantVisibility = "public";
                        i++;
                    } else if (nextArgument.equals("protected")) {
                        slotConstantVisibility = "protected";
                        i++;
                    } else if (nextArgument.equals("package")) {
                        slotConstantVisibility = "";
                        i++;
                    } else if (nextArgument.equals("private")) {
                        slotConstantVisibility = "private";
                        i++;
                    };
                }
                useSlotConstants = true;
            } else if (arg.equals("-haveimports")) {
                haveImports = true;
            } else if (arg.equals("-constructor")) {
                if (i < args.length) {
                    String constructorName = args[++i].toLowerCase();
                    if (constructorName.equals("form")) {
                        formConstructor = true;
                    } else if (constructorName.equals("blank")) {
                        System.out.println("Blank constructor is now not valid");
                        System.exit(1);
                    } else {
                        System.out.println("Unrecognized constructor type "+constructorName);
                        System.exit(1);
                    }
                } else {
                    System.out.println("No type for -constructor");
                    System.exit(1);
                };
            } else if (arg.equals("-getters")) {
                wantGetters = true;
            } else if (arg.equals("-setters")) {
                wantSetters = true;
            } else if (arg.equals("-s")) {
                if (i < args.length) {
                    sourceDirectory = args[++i];
                } else {
                    System.out.println("No source directory for -s.");
                    System.exit(1);
                };
            } else if (arg.equals("-sx")) {
                if (i < args.length) {
                    sourceExtension = args[++i];
                } else {
                    System.out.println("No filename source extension for -sx.");
                    System.exit(1);
                };
            } else if (arg.equals("-builder")) {
                if (i < args.length) {
                    infoBuilderClassName = args[++i];
                } else {
                    System.out.println("No info builder class name with '-builder'.");
                    System.exit(1);
                };
            } else if (arg.equals("-dx")) {
                if (i < args.length) {
                    destinationExtension = args[++i];
                    overwrite = false;
                } else {
                    System.out.println("No filename destination extension for -dx.");
                    System.exit(1);
                };
            } else if (arg.equals("-forminfo")) {
                generateFormInfo = true;
            } else if (arg.equals("-f")) {
                force = true;
                force2 = true;
            } else if (arg.equals("-o")) {
                overwrite = true;
            } else if (arg.equals("-safe")) {
                force = false;
            } else {
                files.addElement(args[i]);
            };
        };
        String[] result = new String[files.size()];
        files.copyInto(result);
        return result;
         }

        /**
         * See the main comment for a description on how to
         * run this class
         */
    public static void main(String args[]) {
        args = getArguments(args);
        if (args.length >= 1) {
            FILE_LOOP:
            for (int i = 0; i < args.length; i++) {
                File file = new File(sourceDirectory,args[i]);
                if (!file.exists()) {
                    System.out.println("File " + args[i] + " not found.");
                    continue FILE_LOOP;
                } else {
                    if (file.isDirectory()) {
                        String[] files = file.list();
                        for (int j = 0; j < files.length; j++) {
                            try {
                                preprocess(new File(file,files[j]));
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        };
                    } else {
                        preprocess(file);
                    };
                };
            };
        } else  if(sourceDirectory != null) {
            File file = new File(sourceDirectory);
            if (!file.exists()) {
                System.out.println("Source directory does not exist");
                System.exit(1);
            } else {
                if (file.isDirectory()) {
                    String[] files = file.list();
                    for (int j = 0; j < files.length; j++) {
                        preprocess(new File(file,files[j]));
                    };
                } else {
                    preprocess(file);
                };
            };
        } else {
            System.out.println("FORM Preprocessor Version "+versionString);
            System.out.println("Usage:");
            System.out.println("    FormPreprocessor [options] (file | directory)*");
            System.out.println("or");
            System.out.println("    java com.chimu.formTools.preprocessor.FormPreprocessor ...");
            System.out.println();
            System.out.println("Options:");
//            System.out.println("  -o                Overwrite the source file (after backing up to ~.bak)");
//            System.out.println();
//            System.out.println("  -compatible       Generate compatibility");
//            System.out.println();
//            System.out.println("    -setters          Generate setter functors for instance variables");
            System.out.println("    -s  <directory>   Source directory");
            System.out.println("    -d  <directory>   Destination directory");
            System.out.println("    -sx <extension>   Source file extension");
            System.out.println("    -dx <extension>   Destination file extension");
            System.out.println();
            System.out.println("    -slotConstants <visibility>? Generate constants for slot names");
            System.out.println("                          Visibility: public, protected, package, private");
            System.out.println();
            System.out.println("    -haveImports      Do not generate full class path names");
            System.out.println("    -getters          Generate getter functors for instance variables");
            System.out.println("    -setters          Generate setter functors for instance variables");
            System.out.println();
            System.out.println("    -formInfo         Generate a FormInfo file");
            System.out.println("    -builder <class>  Use <class> to generate the FormInfo file");
            System.out.println();
            System.out.println("    -f                Force operation even if destination or backup exist");
            System.out.println("    -safe             Do not overwrite existing destination or backup files");
            return;
        }
    }

    static void setClassName(String name) {
        currentOstr.setOuterClassName(name);
    }

    static void setPackageName(String name) {
        currentOstr.setPackageName(name);
    }

    static void setClassModifier(String name) {
        if (name.equals("abstract")) {
            currentOstr.setOuterClassToAbstract();
        };
    }

    static void preprocess(File inFile) {
        System.gc();  //Memory leak or lousy GC
        System.out.print("Processing: "+inFile+"  ");
        String fileName = inFile.getName();
        if (sourceExtension != null) {
            if (!fileName.endsWith(sourceExtension)) {
                return;
            };
        };
        File outfile;
        if (overwrite) {
            String extension = destinationExtension;

            // if sourceExtension then chop off extension
            if (extension == null) extension = ".bak";
            File newInFile = new File(inFile.getPath()+extension);

            if (inFile.renameTo(newInFile)) {
                // System.out.println("Renamed "+file+".");
                // Success
            } else {
                if (force) {
                    if (newInFile.delete() && inFile.renameTo(newInFile)) {
                        // Success
                    } else {
                        System.out.println("Could not remove "+newInFile.getPath()+" and rename "+inFile+" to "+newInFile.getPath()+".");
                        return;
                    };
                } else {
                    System.out.println("Could not rename "+inFile+" to "+newInFile.getPath()+".");
                    return; // failed to rename...
                }
            };
            outfile = inFile;
            inFile  = newInFile;
        } else {
            String extension = destinationExtension;
            if (destinationDirectory != null) {
                if (extension == null) extension = "";
                outfile = new File(destinationDirectory,inFile.getName()+extension);
            } else {
                // if sourceExtension then chop off extension
                if (extension == null) extension = ".out";
                outfile = new File(inFile.getPath()+extension);
            };
        };

        File formInfoFile = null;
        if (generateFormInfo) {
            String extension = sourceExtension;
            if (extension == null) extension = ".java";

            String outfilePath = outfile.getPath();
            int dotIndex = outfilePath.lastIndexOf(".");

            if (dotIndex < 0) {
                formInfoFile = new File(outfilePath+"_FormInfo");
            } else {
                formInfoFile = new File(
                        outfilePath.substring(0,dotIndex)+"_FormInfo"+
                        outfilePath.substring(dotIndex)
                    );
            };
            if (formInfoFile.exists() && !force2) {
                //if (reallyForce) {
                System.out.println("FormInfo file "+formInfoFile.getPath()+" already exists.  Use '-f' to force overwriting ");
                formInfoFile = null;
            };

        }


        FileInputStream fis = null;
        try {
            fis = new FileInputStream(inFile);
            if (parser == null) {
                parser = new FormPreprocessor(fis);
            } else {
                parser.ReInit(fis);
            };
        } catch (Exception e) {
            System.out.println("File " + inFile + " can not be opened.");
            return;
        }

        PrintWriter pw = null;
        PrintWriter infoFilePw = null;
        try {
            pw = new PrintWriter(new FileOutputStream(outfile));

            if (formInfoFile != null) {
                currentOstr = new SourceConverterPrinter(pw,formInfoFile);
            } else {
                currentOstr = new SourceConverterPrinter(pw);
            }

            if (infoBuilderClassName != null) {
                try {
                    Class infoBuilderClass = Class.forName(infoBuilderClassName);
                    InfoBuilder infoBuilder = (InfoBuilder) infoBuilderClass.newInstance();
                    currentOstr.setupInfoBuilder(infoBuilder);
                } catch (Exception e2) {
                    System.out.println("Could not use InfoBuilder: "+infoBuilderClassName);
                    e2.printStackTrace();
                    System.out.println("Using default builder");
                }
                //currentOstr.setupInfoBuilder(null);
            }

            currentOstr.doneSetup();




            ASTCompilationUnit node;
            node = parser.CompilationUnit();

            node.process(currentOstr);

            pw.close();
            fis.close();
            currentOstr.close();

            if (currentOstr.ignoredFile()) {
                System.out.println("IGNORED "+outfile+".");
            } else {
                System.out.println("SUCCESSFUL transformation of "+inFile+" into "+outfile+".");
            }
        } catch (IOException e) {
            System.out.println("Could not write to " + outfile);
        } catch (ParseError e) {
            System.out.print("Could not parse "+inFile);
            if (overwrite) {
                try {
                    pw.close();
                    fis.close();
                } catch (Exception e2) {
                    System.out.println("Could not close the files");
                };
                outfile.delete();
                inFile.renameTo(outfile);
                System.out.println(" restored original "+outfile);
            };
            System.out.println();
        } catch (Throwable e) {
            System.out.print("General Error "+e);
            if (overwrite) {
                try {
                    pw.close();
                    fis.close();
                } catch (Exception e2) {
                    System.out.println("Could not close the files");
                };
                outfile.delete();
                inFile.renameTo(outfile);
                System.out.println(" restored original "+outfile);
            };
            System.out.println();
        } finally {
            try {
                pw.close();
                fis.close();
                if (infoFilePw != null) {
                    infoFilePw.close();
                }
            } catch (Exception e) {
                System.out.println("Could not close the files");
            };
        };

    };
  protected static JJTFormPreprocessorState jjtree = new JJTFormPreprocessorState();
}
final class JJTFormPreprocessorState {
  /* JJTree builds the AST bottom up.  It constructs nodes and places
     them on a stack.  When all the children have been assembled, they
     are added to their parent and popped from the stack. */
  private JJTFormPreprocessorNodeStack nodes;

  /* The current node is kept on the top of this stack so that user
     actions can always refer to it. */
  private java.util.Stack current_nodes;

  /* We keep track of whether a node was actually created.  Definite
     and indefinite nodes always are, but GT nodes are only closed and
     pushed on the stack if their conditions are true. */
  private boolean node_created;

  JJTFormPreprocessorState() {
    nodes = new JJTFormPreprocessorNodeStack();
    current_nodes = new java.util.Stack();
  }

  /* Determine whether the current node was actually closed and pushed */
  boolean nodeCreated() {
    return node_created;
  }

  /* Called when the current node has been completely finished with.
     Makes a new node the current node. */
  void updateCurrentNode(int n) {
    for (int i = 0; i < n; ++i) {
      current_nodes.pop();
    }
  }

  /* Call this to reinitialize the node stack.  */
  void reset() {
    nodes.empty();
    current_nodes = new java.util.Stack();
  }

  /* Return the root node of the AST. */
  Node rootNode() {
    return nodes.elementAt(0);
  }

  /* Return the most recently constructed node. */
  Node currentNode() {
    return (Node)current_nodes.peek();
  }

  /* Push a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
  }

  /* Return the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    return nodes.pop();
  }

  /* Return the node currently on the top of the stack. */
  Node peekNode() {
    return nodes.peek();
  }

  /* An indefinite node has an unspecified number of children.  When
     it is closed it collects up all nodes that have been pushed since
     it was begun and becomes their parent, and then it is pushed on
     to the stack. */

  void openIndefiniteNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeIndefiniteNode() {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTFormPreprocessorNodeEnum e = nodes.elementsSinceLastMark();
	 e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popToLastMark();
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A definite node is constructed from a fixed number of children.
     That number of nodes are popped from the stack and made the
     children of the definite node.  Then the definite node is pushed
     on to the stack. */

  void openDefiniteNode(Node n) {
    current_nodes.push(n);
  }

  void closeDefiniteNode(int num) {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTFormPreprocessorNodeEnum e = nodes.elementsTop(num); e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popTop(num);
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A GT (Greater Than) node is constructed if more than the
     specified number of nodes have been pushed since it was begun.
     All those nodes are made children of the the GT node, which is
     then pushed on to the stack.  If fewer have been pushed the node
     is not constructed and they are left on the stack. */

  void openGTNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeGTNode(int num) {
    if (nodes.numElementsSinceLastMark() > num) {
      closeIndefiniteNode();
    } else {
      nodes.removeLastMark();
      node_created = false;
    }
  }
}

final class JJTFormPreprocessorNodeStack {
  private Node[] nodeStack;
  private int[] markStack;
  private int nodeSP;
  private int markSP;

  JJTFormPreprocessorNodeStack() {
    nodeStack = new Node[500];
    markStack = new int[500];
    nodeSP = 0;
    markSP = 0;
  }

  void empty() {
    if (nodeSP > 0) {
      while (--nodeSP >= 0) {
	nodeStack[nodeSP] = null;
      }
    }
    nodeSP = 0;
    markSP = 0;
  }

  Node elementAt(int i) {
    return nodeStack[i];
  }

  Node elementFromTop(int i) {
    return nodeStack[nodeSP - i - 1];
  }

  void push(Node n) {
    if (nodeSP == nodeStack.length) {
      Node[] ns = new Node[nodeStack.length * 2];
      System.arraycopy(nodeStack, 0, ns, 0, nodeStack.length);
      nodeStack = ns;
    }
    nodeStack[nodeSP++] = n;
  }

  Node pop() {
    Node n = nodeStack[--nodeSP];
    nodeStack[nodeSP] = null;
    return n;
  }

  Node peek() {
    return nodeStack[nodeSP - 1];
  }

  void mark() {
    if (markSP == markStack.length) {
      int[] ms = new int[markStack.length * 2];
      System.arraycopy(markStack, 0, ms, 0, markStack.length);
      markStack = ms;
    }
    markStack[markSP++] = nodeSP;
  }

  void removeLastMark() {
    --markSP;
  }

  int numElementsSinceLastMark() {
    return nodeSP - markStack[markSP - 1];
  }

  JJTFormPreprocessorNodeEnum elementsSinceLastMark() {
    return new JJTFormPreprocessorNodeEnum(nodeStack, nodeSP, markStack[markSP - 1]);
  }

  void popToLastMark() {
    --markSP;
    while (nodeSP > markStack[markSP]) {
      nodeStack[--nodeSP] = null;
    }
  }

  JJTFormPreprocessorNodeEnum elementsTop(int n) {
    return new JJTFormPreprocessorNodeEnum(nodeStack, nodeSP, nodeSP - n);
  }

  void popTop(int n) {
    for (int i = 0; i < n; ++i) {
      nodeStack[--nodeSP] = null;
    }
  }
}

final class JJTFormPreprocessorNodeEnum implements java.util.Enumeration {
  private Node[] nodes;
  private int topSP, index;

  JJTFormPreprocessorNodeEnum(Node[] s, int top, int start) {
    nodes = s;
    topSP = top;
    index = start;
  }

  public boolean hasMoreElements() {
    return index < topSP;
  }

  public Object nextElement() {
    return nodes[index++];
  }
}

PARSER_END(FormPreprocessor)


<DEFAULT> SPECIAL_TOKEN : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
}


<DEFAULT> SPECIAL_TOKEN : {
<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*" )* "/" >
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*" )* "/" >
}


<DEFAULT> TOKEN : {
<ABSTRACT: "abstract">
| <BOOLEAN: "boolean">
| <BREAK: "break">
| <BYTE: "byte">
| <CASE: "case">
| <CATCH: "catch">
| <CHAR: "char">
| <CLASS: "class">
| <CONST: "const">
| <CONTINUE: "continue">
| <_DEFAULT: "default">
| <DO: "do">
| <DOUBLE: "double">
| <ELSE: "else">
| <EXTENDS: "extends">
| <FALSE: "false">
| <FINAL: "final">
| <FINALLY: "finally">
| <FLOAT: "float">
| <FOR: "for">
| <GOTO: "goto">
| <IF: "if">
| <IMPLEMENTS: "implements">
| <IMPORT: "import">
| <INSTANCEOF: "instanceof">
| <INT: "int">
| <INTERFACE: "interface">
| <LONG: "long">
| <NATIVE: "native">
| <NEW: "new">
| <NULL: "null">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RETURN: "return">
| <SHORT: "short">
| <STATIC: "static">
| <SUPER: "super">
| <SWITCH: "switch">
| <SYNCHRONIZED: "synchronized">
| <THIS: "this">
| <THROW: "throw">
| <THROWS: "throws">
| <TRANSIENT: "transient">
| <TRUE: "true">
| <TRY: "try">
| <VOID: "void">
| <VOLATILE: "volatile">
| <WHILE: "while">
}


<DEFAULT> TOKEN : {
<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?  | <HEX_LITERAL> (["l","L"])?  | <OCTAL_LITERAL> (["l","L"])? >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| <#OCTAL_LITERAL: "0" (["0"-"7"])* >
| <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) "\'" >
| <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* "\"" >
}


<DEFAULT> TOKEN : {
<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >
| <#LETTER: ["$","A"-"Z","_","a"-"z","\u00c0"-"\u00d6","\u00d8"-"\u00f6","\u00f8"-"\u00ff","\u0100"-"\u1fff","\u3040"-"\u318f","\u3300"-"\u337f","\u3400"-"\u3d2d","\u4e00"-"\u9fff","\uf900"-"\ufaff"]>
| <#DIGIT: ["0"-"9","\u0660"-"\u0669","\u06f0"-"\u06f9","\u0966"-"\u096f","\u09e6"-"\u09ef","\u0a66"-"\u0a6f","\u0ae6"-"\u0aef","\u0b66"-"\u0b6f","\u0be7"-"\u0bef","\u0c66"-"\u0c6f","\u0ce6"-"\u0cef","\u0d66"-"\u0d6f","\u0e50"-"\u0e59","\u0ed0"-"\u0ed9","\u1040"-"\u1049"]>
}


<DEFAULT> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
}


<DEFAULT> TOKEN : {
<ASSIGN: "=">
| <GT: ">">
| <LT: "<">
| <BANG: "!">
| <TILDE: "~">
| <HOOK: "?">
| <COLON: ":">
| <EQ: "==">
| <LE: "<=">
| <GE: ">=">
| <NE: "!=">
| <SC_OR: "||">
| <SC_AND: "&&">
| <INCR: "++">
| <DECR: "--">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <SLASH: "/">
| <BIT_AND: "&">
| <BIT_OR: "|">
| <XOR: "^">
| <REM: "%">
| <LSHIFT: "<<">
| <RSIGNEDSHIFT: ">>">
| <RUNSIGNEDSHIFT: ">>>">
| <PLUSASSIGN: "+=">
| <MINUSASSIGN: "-=">
| <STARASSIGN: "*=">
| <SLASHASSIGN: "/=">
| <ANDASSIGN: "&=">
| <ORASSIGN: "|=">
| <XORASSIGN: "^=">
| <REMASSIGN: "%=">
| <LSHIFTASSIGN: "<<=">
| <RSIGNEDSHIFTASSIGN: ">>=">
| <RUNSIGNEDSHIFTASSIGN: ">>>=">
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTCompilationUnit CompilationUnit() /*#CompilationUnit*/ : {}
{
{
jjtree.openIndefiniteNode(ASTCompilationUnit.jjtCreate("CompilationUnit"));
}
 { try {
ASTCompilationUnit jjtThis = (ASTCompilationUnit)jjtree.currentNode();
jjtThis.firstToken=getToken(1);
} finally {
}
}
 (  PackageDeclaration() )? (  ImportDeclaration() )* (  TypeDeclaration() )* <EOF> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTCompilationUnit jjtThis = (ASTCompilationUnit)jjtree.currentNode();
return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

void PackageDeclaration() /*#PackageDeclaration*/ : {}
{
{
jjtree.openIndefiniteNode(ASTPackageDeclaration.jjtCreate("PackageDeclaration"));
}
 "package" Name() ";"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void ImportDeclaration() /*#void*/ : {}
{
 "import" Name() (  "." "*" )? ";"
}

void TypeDeclaration() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  (  "abstract" |  "final" |  "public"  )* "class") ClassDeclaration()
|  InterfaceDeclaration()
|  ";"

}

/*
 * Declaration syntax follows.
 */

void ClassDeclaration() /*#void*/ :
{
Token   t;
}
{
 (  (  "abstract" |  "final" |  "public"  ) { try {
t = getToken(0);
        setClassModifier(t.image);
} finally {
}
}
 )* UnmodifiedClassDeclaration()
}

void UnmodifiedClassDeclaration() /*#void*/ :
{
Token t;
}
{
 "class" t=<IDENTIFIER> { try {
setClassName(t.image);
} finally {
}
}
 (  "extends" Name() )? (  "implements" NameList() )? ClassBody()
}

void ClassBody() /*#ClassBody*/ :
{
Token   firstToken;
}
{
{
jjtree.openIndefiniteNode(ASTClassBody.jjtCreate("ClassBody"));
}
 { try {
ASTClassBody jjtThis = (ASTClassBody)jjtree.currentNode();
firstToken = getToken(1);
} finally {
}
}
 "{" (  ClassBodyDeclaration() )* "}" {
jjtree.closeIndefiniteNode();
}
{ try {
ASTClassBody jjtThis = (ASTClassBody)jjtree.currentNode();
jjtThis.firstToken = firstToken;
                   jjtThis.lastToken  = getToken(0);
} finally {
jjtree.updateCurrentNode(1);
}
}

}

void NestedClassDeclaration() /*#void*/ : {}
{
 (  "static" |  "abstract" |  "final" |  "public" |  "protected" |  "private"  )* UnmodifiedClassDeclaration()
}

void ClassBodyDeclaration() /*#void*/ : {}
{
LOOKAHEAD(2) Initializer()
| LOOKAHEAD(2147483647,  (  "static" |  "abstract" |  "final" |  "public" |  "protected" |  "private"  )* "class") NestedClassDeclaration()
| LOOKAHEAD(2147483647,  (  "static" |  "abstract" |  "final" |  "public" |  "protected" |  "private"  )* "interface") NestedInterfaceDeclaration()
| LOOKAHEAD(2147483647,  (  "public" |  "protected" |  "private"  )? Name() "(") ConstructorDeclaration()
| LOOKAHEAD(2147483647,  MethodDeclarationLookahead()) MethodDeclaration()
|  FieldDeclaration()

}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() /*#void*/ : {}
{
 (  "public" |  "protected" |  "private" |  "static" |  "abstract" |  "final" |  "native" |  "synchronized"  )* ResultType() <IDENTIFIER> "("
}

void InterfaceDeclaration() /*#void*/ : {}
{
 (  "abstract" |  "public"  )* UnmodifiedInterfaceDeclaration()
}

void NestedInterfaceDeclaration() /*#void*/ : {}
{
 (  "static" |  "abstract" |  "final" |  "public" |  "protected" |  "private"  )* UnmodifiedInterfaceDeclaration()
}

void UnmodifiedInterfaceDeclaration() /*#void*/ : {}
{
 "interface" <IDENTIFIER> (  "extends" NameList() )? "{" (  InterfaceMemberDeclaration() )* "}"
}

void InterfaceMemberDeclaration() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  (  "static" |  "abstract" |  "final" |  "public" |  "protected" |  "private"  )* "class") NestedClassDeclaration()
| LOOKAHEAD(2147483647,  (  "static" |  "abstract" |  "final" |  "public" |  "protected" |  "private"  )* "interface") NestedInterfaceDeclaration()
| LOOKAHEAD(2147483647,  MethodDeclarationLookahead()) MethodDeclaration()
|  FieldDeclaration()

}

void FieldDeclaration() /*#FieldDeclaration*/ :
{
Token   t,firstToken;
                   Vector modifiers = new Vector();
}
{
{
jjtree.openIndefiniteNode(ASTFieldDeclaration.jjtCreate("FieldDeclaration"));
}
 { try {
ASTFieldDeclaration jjtThis = (ASTFieldDeclaration)jjtree.currentNode();
firstToken = getToken(1);
} finally {
}
}
 (  (  "public" |  "protected" |  "private" |  "static" |  "final" |  "transient" |  "volatile"  ) { try {
ASTFieldDeclaration jjtThis = (ASTFieldDeclaration)jjtree.currentNode();
t = getToken(0);
        modifiers.addElement(t.image);
} finally {
}
}
 )* { try {
ASTFieldDeclaration jjtThis = (ASTFieldDeclaration)jjtree.currentNode();
t = getToken(1);
} finally {
}
}
 Type() VariableDeclarator() (  "," VariableDeclarator() )* { try {
ASTFieldDeclaration jjtThis = (ASTFieldDeclaration)jjtree.currentNode();
jjtThis.firstTypeVariableToken =t;
                   jjtThis.lastTypeVariableToken  =getToken(0);
                   jjtThis.setModifiers(modifiers);
} finally {
}
}
 ";" {
jjtree.closeIndefiniteNode();
}
{ try {
ASTFieldDeclaration jjtThis = (ASTFieldDeclaration)jjtree.currentNode();
jjtThis.firstToken = firstToken;
                   jjtThis.lastToken  = getToken(0);
} finally {
jjtree.updateCurrentNode(1);
}
}

}

void VariableDeclarator() /*#void*/ : {}
{
 VariableDeclaratorId() (  "=" VariableInitializer() )?
}

void VariableDeclaratorId() /*#void*/ : {}
{
 <IDENTIFIER> (  "[" "]" )*
}

void VariableInitializer() /*#void*/ : {}
{
 ArrayInitializer()
|  Expression()

}

void ArrayInitializer() /*#void*/ : {}
{
 "{" (  VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* )? (  "," )? "}"
}

void MethodDeclaration() /*#void*/ :
{
Token   t;
                   boolean protectedFlag = false;
                   boolean hasSpecialFlag = false;
                   Vector modifiers = new Vector();
}
{
 (  (  "public" |  "protected" |  "private" |  "static" |  "abstract" |  "final" |  "native" |  "synchronized"  ) { try {
t = getToken(0);
        modifiers.addElement(t.image);
} finally {
}
}
 )* ResultType() MethodDeclarator() (  "throws" NameList() )? (  ( ( {
jjtree.openIndefiniteNode(ASTSpecialBlock.jjtCreate("SpecialBlock"));
}
 { try {
ASTSpecialBlock jjtThis = (ASTSpecialBlock)jjtree.currentNode();
t = getToken(1);
} finally {
}
}
 Block() (  (  (  "catch" "(" FormalParameter() ")" Block() )+ (  "finally" Block() )? |  "finally" Block()  ) { try {
ASTSpecialBlock jjtThis = (ASTSpecialBlock)jjtree.currentNode();
hasSpecialFlag = true;
} finally {
}
}
 )? { try {
ASTSpecialBlock jjtThis = (ASTSpecialBlock)jjtree.currentNode();
jjtThis.firstToken =t;
                   jjtThis.lastToken  =getToken(0);
                   jjtThis.setModifiers(modifiers);
                   jjtThis.setHasSpecialFlag(hasSpecialFlag);
} finally {
}
}
 (  ";" )?{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 ) /*#SpecialBlock*/ ) |  ";"  )
}

void MethodDeclarator() /*#void*/ : {}
{
 <IDENTIFIER> FormalParameters() (  "[" "]" )*
}

void FormalParameters() /*#void*/ : {}
{
 "(" (  FormalParameter() (  "," FormalParameter() )* )? ")"
}

void FormalParameter() /*#void*/ : {}
{
 (  "final" )? Type() VariableDeclaratorId()
}

void ConstructorDeclaration() /*#void*/ : {}
{
 (  "public" |  "protected" |  "private"  )? <IDENTIFIER> FormalParameters() (  "throws" NameList() )? "{" ( LOOKAHEAD(2147483647,  ExplicitConstructorInvocation()) ExplicitConstructorInvocation() )? (  BlockStatement() )* "}" (  ";" )?
}

void ExplicitConstructorInvocation() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  "this" Arguments() ";") "this" Arguments() ";"
|  ( LOOKAHEAD(2) PrimaryExpression() "." )? "super" Arguments() ";"

}

void Initializer() /*#void*/ : {}
{
 (  "static" )? Block()
}

/*
 * Type, name and expression syntax follows.
 */

void Type() /*#void*/ : {}
{
 (  PrimitiveType() |  Name()  ) (  "[" "]" )*
}

void PrimitiveType() /*#PrimitiveType*/ : {}
{
{
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "boolean"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "char"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "byte"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "short"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "int"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "long"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "float"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

| {
jjtree.openIndefiniteNode(ASTPrimitiveType.jjtCreate("PrimitiveType"));
}
 "double"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}


}

void ResultType() /*#void*/ : {}
{
 "void"
|  Type()

}

void Name() /*#Name*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTName.jjtCreate("Name"));
}
 t=<IDENTIFIER> { try {
ASTName jjtThis = (ASTName)jjtree.currentNode();
jjtThis.appendName(t.image);
} finally {
}
}
 ( LOOKAHEAD(2) "." t=<IDENTIFIER> { try {
ASTName jjtThis = (ASTName)jjtree.currentNode();
jjtThis.appendName("."+t.image);
} finally {
}
}
 )*{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void NameList() /*#void*/ : {}
{
 Name() (  "," Name() )*
}

/*
 * Expression syntax follows.
 */

void Expression() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  PrimaryExpression() AssignmentOperator()) Assignment()
|  ConditionalExpression()

}

void Assignment() /*#void*/ : {}
{
 PrimaryExpression() AssignmentOperator() Expression()
}

void AssignmentOperator() /*#void*/ : {}
{
 "="
|  "*="
|  "/="
|  "%="
|  "+="
|  "-="
|  "<<="
|  ">>="
|  ">>>="
|  "&="
|  "^="
|  "|="

}

void ConditionalExpression() /*#void*/ : {}
{
 ConditionalOrExpression() (  "?" Expression() ":" ConditionalExpression() )?
}

void ConditionalOrExpression() /*#void*/ : {}
{
 ConditionalAndExpression() (  "||" ConditionalAndExpression() )*
}

void ConditionalAndExpression() /*#void*/ : {}
{
 InclusiveOrExpression() (  "&&" InclusiveOrExpression() )*
}

void InclusiveOrExpression() /*#void*/ : {}
{
 ExclusiveOrExpression() (  "|" ExclusiveOrExpression() )*
}

void ExclusiveOrExpression() /*#void*/ : {}
{
 AndExpression() (  "^" AndExpression() )*
}

void AndExpression() /*#void*/ : {}
{
 EqualityExpression() (  "&" EqualityExpression() )*
}

void EqualityExpression() /*#void*/ : {}
{
 InstanceOfExpression() (  (  "==" |  "!="  ) InstanceOfExpression() )*
}

void InstanceOfExpression() /*#void*/ : {}
{
 RelationalExpression() (  "instanceof" Type() )?
}

void RelationalExpression() /*#void*/ : {}
{
 ShiftExpression() (  (  "<" |  ">" |  "<=" |  ">="  ) ShiftExpression() )*
}

void ShiftExpression() /*#void*/ : {}
{
 AdditiveExpression() (  (  "<<" |  ">>" |  ">>>"  ) AdditiveExpression() )*
}

void AdditiveExpression() /*#void*/ : {}
{
 MultiplicativeExpression() (  (  "+" |  "-"  ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() /*#void*/ : {}
{
 UnaryExpression() (  (  "*" |  "/" |  "%"  ) UnaryExpression() )*
}

void UnaryExpression() /*#void*/ : {}
{
 (  "+" |  "-"  ) UnaryExpression()
|  PreIncrementExpression()
|  PreDecrementExpression()
|  UnaryExpressionNotPlusMinus()

}

void PreIncrementExpression() /*#void*/ : {}
{
 "++" PrimaryExpression()
}

void PreDecrementExpression() /*#void*/ : {}
{
 "--" PrimaryExpression()
}

void UnaryExpressionNotPlusMinus() /*#void*/ : {}
{
 (  "~" |  "!"  ) UnaryExpression()
| LOOKAHEAD(2147483647,  CastLookahead()) CastExpression()
|  PostfixExpression()

}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() /*#void*/ : {}
{
LOOKAHEAD(2) "(" PrimitiveType()
| LOOKAHEAD(2147483647,  "(" Name() "[") "(" Name() "[" "]"
|  "(" Name() ")" (  "~" |  "!" |  "(" |  <IDENTIFIER> |  "this" |  "super" |  "new" |  "[" |  Literal()  )

}

//MLF960327  added the "[" in the cast expression

void PostfixExpression() /*#void*/ : {}
{
 PrimaryExpression() (  "++" |  "--"  )?
}

void CastExpression() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  "(" PrimitiveType()) "(" Type() ")" UnaryExpression()
| LOOKAHEAD(2147483647,  "(" Name()) "(" Type() ")" UnaryExpressionNotPlusMinus()

}

void PrimaryExpression() /*#void*/ : {}
{
 PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void PrimaryPrefix() /*#void*/ : {}
{
 Literal()
|  Name()
|  "this"
|  "super" "." <IDENTIFIER>
|  "(" Expression() ")"
|  FunctorBlock()
|  AllocationExpression()

}

//MLF Added the functor block
//*************************************************

void FunctorBlock() /*#FunctorBlock*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTFunctorBlock.jjtCreate("FunctorBlock"));
}
 { try {
ASTFunctorBlock jjtThis = (ASTFunctorBlock)jjtree.currentNode();
jjtThis.firstToken=getToken(1);
} finally {
}
}
 "[" (  FunctorParameterList() )? "|" (  { try {
ASTFunctorBlock jjtThis = (ASTFunctorBlock)jjtree.currentNode();
jjtThis.startBlockStatements=getToken(1);
} finally {
}
}
 (  BlockStatement() )* { try {
ASTFunctorBlock jjtThis = (ASTFunctorBlock)jjtree.currentNode();
jjtThis.endBlockStatements=getToken(0);
} finally {
}
}
 ) "]" {
jjtree.closeIndefiniteNode();
}
{ try {
ASTFunctorBlock jjtThis = (ASTFunctorBlock)jjtree.currentNode();
jjtThis.lastToken=getToken(0);
} finally {
jjtree.updateCurrentNode(1);
}
}

}

void FunctorParameterList() /*#FunctorParameterList*/ : {}
{
{
jjtree.openIndefiniteNode(ASTFunctorParameterList.jjtCreate("FunctorParameterList"));
}
 FunctorParameter() (  "," FunctorParameter() )*{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void FunctorParameter() /*#void*/ : {}
{
 FunctorType()
|  FunctorInputParameter()
|  FunctorResultType()

}

void FunctorInputParameter() /*#FunctorInputParameter*/ :
{
Token startToken;
}
{
{
jjtree.openIndefiniteNode(ASTFunctorInputParameter.jjtCreate("FunctorInputParameter"));
}
 { try {
ASTFunctorInputParameter jjtThis = (ASTFunctorInputParameter)jjtree.currentNode();
jjtThis.startNameToken=getToken(1);
} finally {
}
}
 ( LOOKAHEAD(2147483647,  Type() <IDENTIFIER>) FormalParameter() |  Name()  ) { try {
ASTFunctorInputParameter jjtThis = (ASTFunctorInputParameter)jjtree.currentNode();
jjtThis.endNameToken=getToken(0);
} finally {
}
}
 (  "=" { try {
ASTFunctorInputParameter jjtThis = (ASTFunctorInputParameter)jjtree.currentNode();
jjtThis.startPrimaryPrefix=getToken(1);
} finally {
}
}
 PrimaryPrefix() { try {
ASTFunctorInputParameter jjtThis = (ASTFunctorInputParameter)jjtree.currentNode();
jjtThis.endPrimaryPrefix=getToken(0);
            jjtThis.setHasEquals(true);
} finally {
}
}
 )?{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void FunctorType() /*#FunctorType*/ : {}
{
{
jjtree.openIndefiniteNode(ASTFunctorType.jjtCreate("FunctorType"));
}
 "(" { try {
ASTFunctorType jjtThis = (ASTFunctorType)jjtree.currentNode();
jjtThis.startNameToken=getToken(1);
} finally {
}
}
 Type() { try {
ASTFunctorType jjtThis = (ASTFunctorType)jjtree.currentNode();
jjtThis.endNameToken=getToken(0);
} finally {
}
}
 ")"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void FunctorResultType() /*#FunctorResultType*/ : {}
{
{
jjtree.openIndefiniteNode(ASTFunctorResultType.jjtCreate("FunctorResultType"));
}
 "^" { try {
ASTFunctorResultType jjtThis = (ASTFunctorResultType)jjtree.currentNode();
jjtThis.startNameToken=getToken(1);
} finally {
}
}
 (  ResultType() ) {
jjtree.closeIndefiniteNode();
}
{ try {
ASTFunctorResultType jjtThis = (ASTFunctorResultType)jjtree.currentNode();
jjtThis.endNameToken=getToken(0);
} finally {
jjtree.updateCurrentNode(1);
}
}

}

//*************************************************

void PrimarySuffix() /*#void*/ : {}
{
LOOKAHEAD(2) "." "this"
| LOOKAHEAD(2) "." "class"
| LOOKAHEAD(2) "." AllocationExpression()
|  "[" Expression() "]"
|  "." <IDENTIFIER>
|  Arguments()

}

void Literal() /*#void*/ : {}
{
 <INTEGER_LITERAL>
|  <FLOATING_POINT_LITERAL>
|  <CHARACTER_LITERAL>
|  <STRING_LITERAL>
|  BooleanLiteral()
|  NullLiteral()

}

void BooleanLiteral() /*#void*/ : {}
{
 "true"
|  "false"

}

void NullLiteral() /*#void*/ : {}
{
 "null"
}

void Arguments() /*#void*/ : {}
{
 "(" (  ArgumentList() )? ")"
}

void ArgumentList() /*#void*/ : {}
{
 Expression() (  "," Expression() )*
}

void AllocationExpression() /*#void*/ : {}
{
LOOKAHEAD(2) "new" PrimitiveType() ArrayDimensions() (  ArrayInitializer() )?
|  "new" Name() (  ArrayDimensions() (  ArrayInitializer() )? |  Arguments() (  ClassBody() )?  )

}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimensions() /*#void*/ : {}
{
 ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
}

/*
 * Statement syntax follows.
 */

void Statement() /*#void*/ : {}
{
LOOKAHEAD(2) LabeledStatement()
|  Block()
|  EmptyStatement()
|  StatementExpression() ";"
|  SwitchStatement()
|  IfStatement()
|  WhileStatement()
|  DoStatement()
|  ForStatement()
|  BreakStatement()
|  ContinueStatement()
|  ReturnStatement()
|  ThrowStatement()
|  SynchronizedStatement()
|  TryStatement()

}

void LabeledStatement() /*#void*/ : {}
{
 <IDENTIFIER> ":" Statement()
}

void Block() /*#void*/ : {}
{
 "{" (  BlockStatement() )* "}"
}

void BlockStatement() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  (  "final" )? Type() <IDENTIFIER>) LocalVariableDeclaration() ";"
|  Statement()
|  UnmodifiedClassDeclaration()

}

void LocalVariableDeclaration() /*#void*/ : {}
{
 (  "final" )? Type() VariableDeclarator() (  "," VariableDeclarator() )*
}

void EmptyStatement() /*#void*/ : {}
{
 ";"
}

void StatementExpression() /*#void*/ : {}
{
 PreIncrementExpression()
|  PreDecrementExpression()
| LOOKAHEAD(2147483647,  PrimaryExpression() AssignmentOperator()) Assignment()
|  PostfixExpression()

}

void SwitchStatement() /*#void*/ : {}
{
 "switch" "(" Expression() ")" "{" (  SwitchLabel() (  BlockStatement() )* )* "}"
}

void SwitchLabel() /*#void*/ : {}
{
 "case" Expression() ":"
|  "default" ":"

}

void IfStatement() /*#void*/ : {}
{
 "if" "(" Expression() ")" Statement() ( LOOKAHEAD(1) "else" Statement() )?
}

void WhileStatement() /*#void*/ : {}
{
 "while" "(" Expression() ")" Statement()
}

void DoStatement() /*#void*/ : {}
{
 "do" Statement() "while" "(" Expression() ")" ";"
}

void ForStatement() /*#void*/ : {}
{
 "for" "(" (  ForInit() )? ";" (  Expression() )? ";" (  ForUpdate() )? ")" Statement()
}

void ForInit() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  (  "final" )? Type() <IDENTIFIER>) LocalVariableDeclaration()
|  StatementExpressionList()

}

void StatementExpressionList() /*#void*/ : {}
{
 StatementExpression() (  "," StatementExpression() )*
}

void ForUpdate() /*#void*/ : {}
{
 StatementExpressionList()
}

void BreakStatement() /*#void*/ : {}
{
 "break" (  <IDENTIFIER> )? ";"
}

void ContinueStatement() /*#void*/ : {}
{
 "continue" (  <IDENTIFIER> )? ";"
}

void ReturnStatement() /*#void*/ : {}
{
 "return" (  Expression() )? ";"
}

void ThrowStatement() /*#void*/ : {}
{
 "throw" Expression() ";"
}

void SynchronizedStatement() /*#void*/ : {}
{
 "synchronized" "(" Expression() ")" Block()
}

void TryStatement() /*#void*/ : {}
{
 "try" Block() (  "catch" "(" FormalParameter() ")" Block() )* (  "finally" Block() )?
}

