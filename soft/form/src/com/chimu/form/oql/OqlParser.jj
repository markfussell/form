/* Generated By:JJTree: Do not edit this line. OqlParser.jj */
options {
ERROR_REPORTING=true;
STATIC=false;
USER_CHAR_STREAM=false;
OTHER_AMBIGUITY_CHECK=1;
BUILD_TOKEN_MANAGER=true;
DEBUG_TOKEN_MANAGER=false;
DEBUG_LOOKAHEAD=false;
USER_TOKEN_MANAGER=false;
LOOKAHEAD=1;
IGNORE_CASE=false;
FORCE_LA_CHECK=false;
SANITY_CHECK=true;
JAVA_UNICODE_ESCAPE=true;
CHOICE_AMBIGUITY_CHECK=2;
BUILD_PARSER=true;
DEBUG_PARSER=false;
COMMON_TOKEN_ACTION=false;
UNICODE_INPUT=false;
}

PARSER_BEGIN(OqlParser)
package COM.chimu.form.oql;

/**
FORM's OQL Parser.
**/
public class OqlParser{
  public static void main(String args[]) {
    OqlParser parser;
    if (args.length == 0) {
      System.out.println("OqlParser Parser:  Reading from standard input . . .");
      parser = new OqlParser(new java.io.DataInputStream(System.in));
    } else if (args.length == 1) {
      System.out.println("OqlParser Parser:  Reading from file " + args[0] + " . . .");
      try {
        parser = new OqlParser(new java.io.DataInputStream(new java.io.FileInputStream(args[0])));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("OqlParser Parser Version 1.1:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("OqlParser Parser:  Usage is one of:");
      System.out.println("         java OqlParser < inputfile");
      System.out.println("OR");
      System.out.println("         java OqlParser inputfile");
      return;
    }
    try {
      parser.Query();
     ((SimpleNode) parser.jjtree.rootNode()).dump("");
      System.out.println("OqlParser Parser:  Oql program parsed successfully.");
    } catch (ParseError e) {
      System.out.println("OqlParser Parser:  Encountered errors during parse.");
    }
  }
  protected JJTOqlParserState jjtree = new JJTOqlParserState();
}
final class JJTOqlParserState {
  /* JJTree builds the AST bottom up.  It constructs nodes and places
     them on a stack.  When all the children have been assembled, they
     are added to their parent and popped from the stack. */
  private JJTOqlParserNodeStack nodes;

  /* The current node is kept on the top of this stack so that user
     actions can always refer to it. */
  private java.util.Stack current_nodes;

  /* We keep track of whether a node was actually created.  Definite
     and indefinite nodes always are, but GT nodes are only closed and
     pushed on the stack if their conditions are true. */
  private boolean node_created;

  JJTOqlParserState() {
    nodes = new JJTOqlParserNodeStack();
    current_nodes = new java.util.Stack();
  }

  /* Determine whether the current node was actually closed and pushed */
  boolean nodeCreated() {
    return node_created;
  }

  /* Called when the current node has been completely finished with.
     Makes a new node the current node. */
  void updateCurrentNode(int n) {
    for (int i = 0; i < n; ++i) {
      current_nodes.pop();
    }
  }

  /* Call this to reinitialize the node stack.  */
  void reset() {
    nodes.empty();
    current_nodes = new java.util.Stack();
  }

  /* Return the root node of the AST. */
  Node rootNode() {
    return nodes.elementAt(0);
  }

  /* Return the most recently constructed node. */
  Node currentNode() {
    return (Node)current_nodes.peek();
  }

  /* Push a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
  }

  /* Return the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    return nodes.pop();
  }

  /* Return the node currently on the top of the stack. */
  Node peekNode() {
    return nodes.peek();
  }

  /* An indefinite node has an unspecified number of children.  When
     it is closed it collects up all nodes that have been pushed since
     it was begun and becomes their parent, and then it is pushed on
     to the stack. */

  void openIndefiniteNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeIndefiniteNode() {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTOqlParserNodeEnum e = nodes.elementsSinceLastMark();
	 e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popToLastMark();
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A definite node is constructed from a fixed number of children.
     That number of nodes are popped from the stack and made the
     children of the definite node.  Then the definite node is pushed
     on to the stack. */

  void openDefiniteNode(Node n) {
    current_nodes.push(n);
  }

  void closeDefiniteNode(int num) {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTOqlParserNodeEnum e = nodes.elementsTop(num); e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popTop(num);
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A GT (Greater Than) node is constructed if more than the
     specified number of nodes have been pushed since it was begun.
     All those nodes are made children of the the GT node, which is
     then pushed on to the stack.  If fewer have been pushed the node
     is not constructed and they are left on the stack. */

  void openGTNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeGTNode(int num) {
    if (nodes.numElementsSinceLastMark() > num) {
      closeIndefiniteNode();
    } else {
      nodes.removeLastMark();
      node_created = false;
    }
  }
}

final class JJTOqlParserNodeStack {
  private Node[] nodeStack;
  private int[] markStack;
  private int nodeSP;
  private int markSP;

  JJTOqlParserNodeStack() {
    nodeStack = new Node[500];
    markStack = new int[500];
    nodeSP = 0;
    markSP = 0;
  }

  void empty() {
    if (nodeSP > 0) {
      while (--nodeSP >= 0) {
	nodeStack[nodeSP] = null;
      }
    }
    nodeSP = 0;
    markSP = 0;
  }

  Node elementAt(int i) {
    return nodeStack[i];
  }

  Node elementFromTop(int i) {
    return nodeStack[nodeSP - i - 1];
  }

  void push(Node n) {
    if (nodeSP == nodeStack.length) {
      Node[] ns = new Node[nodeStack.length * 2];
      System.arraycopy(nodeStack, 0, ns, 0, nodeStack.length);
      nodeStack = ns;
    }
    nodeStack[nodeSP++] = n;
  }

  Node pop() {
    Node n = nodeStack[--nodeSP];
    nodeStack[nodeSP] = null;
    return n;
  }

  Node peek() {
    return nodeStack[nodeSP - 1];
  }

  void mark() {
    if (markSP == markStack.length) {
      int[] ms = new int[markStack.length * 2];
      System.arraycopy(markStack, 0, ms, 0, markStack.length);
      markStack = ms;
    }
    markStack[markSP++] = nodeSP;
  }

  void removeLastMark() {
    --markSP;
  }

  int numElementsSinceLastMark() {
    return nodeSP - markStack[markSP - 1];
  }

  JJTOqlParserNodeEnum elementsSinceLastMark() {
    return new JJTOqlParserNodeEnum(nodeStack, nodeSP, markStack[markSP - 1]);
  }

  void popToLastMark() {
    --markSP;
    while (nodeSP > markStack[markSP]) {
      nodeStack[--nodeSP] = null;
    }
  }

  JJTOqlParserNodeEnum elementsTop(int n) {
    return new JJTOqlParserNodeEnum(nodeStack, nodeSP, nodeSP - n);
  }

  void popTop(int n) {
    for (int i = 0; i < n; ++i) {
      nodeStack[--nodeSP] = null;
    }
  }
}

final class JJTOqlParserNodeEnum implements java.util.Enumeration {
  private Node[] nodes;
  private int topSP, index;

  JJTOqlParserNodeEnum(Node[] s, int top, int start) {
    nodes = s;
    topSP = top;
    index = start;
  }

  public boolean hasMoreElements() {
    return index < topSP;
  }

  public Object nextElement() {
    return nodes[index++];
  }
}

PARSER_END(OqlParser)


<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
}


<DEFAULT> SPECIAL_TOKEN : {
<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*" )* "/" >
}


<DEFAULT> TOKEN [IGNORE_CASE] : {
<BANG: "!">
| <TILDE: "~">
| <EQ: "=">
| <EQ2: "==">
| <NE: "!=">
| <NE2: "<>">
| <GT: ">">
| <LT: "<">
| <LE: "<=">
| <GE: ">=">
| <PLUS: "+">
| <MINUS: "-">
| <TIMES: "*">
| <DIVIDE: "/">
| <REM: "%">
| <AND: "&" | "AND">
| <OR: "|" | "OR">
| <XOR: "^">
}


<DEFAULT> TOKEN [IGNORE_CASE] : {
<IN: "in">
| <WHERE: "where">
| <AS: "as">
| <SELECT: "select">
| <FROM: "from">
| <NULL: "null">
| <TRUE: "true">
| <FALSE: "false">
}


<DEFAULT> TOKEN : {
<DOLLAR: "$">
| <COLON: ":">
}


<DEFAULT> TOKEN : {
<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >
| <#LETTER: ["A"-"Z","_","a"-"z","\u00c0"-"\u00d6","\u00d8"-"\u00f6","\u00f8"-"\u00ff","\u0100"-"\u1fff","\u3040"-"\u318f","\u3300"-"\u337f","\u3400"-"\u3d2d","\u4e00"-"\u9fff","\uf900"-"\ufaff"]>
| <#DIGIT: ["0"-"9","\u0660"-"\u0669","\u06f0"-"\u06f9","\u0966"-"\u096f","\u09e6"-"\u09ef","\u0a66"-"\u0a6f","\u0ae6"-"\u0aef","\u0b66"-"\u0b6f","\u0be7"-"\u0bef","\u0c66"-"\u0c6f","\u0ce6"-"\u0cef","\u0d66"-"\u0d6f","\u0e50"-"\u0e59","\u0ed0"-"\u0ed9","\u1040"-"\u1049"]>
}


<DEFAULT> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <COMMA: ",">
| <DOT: ".">
| <RARROW: "->">
}


<DEFAULT> TOKEN : {
<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?  | <HEX_LITERAL> (["l","L"])?  | <OCTAL_LITERAL> (["l","L"])? >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| <#OCTAL_LITERAL: "0" (["0"-"7"])* >
| <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <STRING_LITERAL2: "\'" (~["\'","\\"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* "\'" >
| <STRING_LITERAL: "\"" (~["\"","\\"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* "\"" >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void Query() /*#void*/ : {}
{
 (  SelectQuery() |  FromQuery() |  WhereQuery()  ) <EOF>
}

void SelectQuery() /*#SelectQuery*/ : {}
{
{
jjtree.openIndefiniteNode(ASTSelectQuery.jjtCreate("SelectQuery"));
}
 SelectClause() FromClause() (  WhereClause() )?{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void FromQuery() /*#FromQuery*/ : {}
{
{
jjtree.openIndefiniteNode(ASTFromQuery.jjtCreate("FromQuery"));
}
 FromClause() (  WhereClause() )?{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void WhereQuery() /*#WhereQuery*/ : {}
{
{
jjtree.openIndefiniteNode(ASTWhereQuery.jjtCreate("WhereQuery"));
}
 WhereClause(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void SelectClause() /*#SelectClause*/ : {}
{
{
jjtree.openIndefiniteNode(ASTSelectClause.jjtCreate("SelectClause"));
}
 <SELECT> ExpressionList(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void FromClause() /*#FromClause*/ : {}
{
{
jjtree.openIndefiniteNode(ASTFromClause.jjtCreate("FromClause"));
}
 <FROM> RangeList(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void WhereClause() /*#WhereClause*/ : {}
{
{
jjtree.openIndefiniteNode(ASTWhereClause.jjtCreate("WhereClause"));
}
 <WHERE> Condition(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

// **********************************************************
// **********************************************************
// **********************************************************

void RangeList() /*#RangeList*/ : {}
{
{
jjtree.openIndefiniteNode(ASTRangeList.jjtCreate("RangeList"));
}
 Range() (  <COMMA> Range() )*{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void Range() /*#Range*/ : {}
{
{
jjtree.openIndefiniteNode(ASTRange.jjtCreate("Range"));
}
 MessageSequence() (  (  <AS> )? Name() )?{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

//    Name()
//    (<IN> MessageSequence())?
// **********************************************************

// These are the condition expressions that can be in the where part of a query
void ExpressionList() /*#void*/ : {}
{
 LabeledExpression() (  <COMMA> LabeledExpression() )*
}

void LabeledExpression() /*#LabeledExpression(>1)*/ : {}
{
{
jjtree.openGTNode(ASTLabeledExpression.jjtCreate("LabeledExpression"));
}
 Expression() (  <AS> Name() )?{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void Expression() /*#void*/ : {}
{
 InclusiveOrCondition()
}

void Condition() /*#void*/ : {}
{
 InclusiveOrCondition()
}

void InclusiveOrCondition() /*#InclusiveOrCondition(>1)*/ : {}
{
{
jjtree.openGTNode(ASTInclusiveOrCondition.jjtCreate("InclusiveOrCondition"));
}
 ExclusiveOrCondition() (  <OR> ExclusiveOrCondition() )*{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void ExclusiveOrCondition() /*#ExclusiveOrCondition(>1)*/ : {}
{
{
jjtree.openGTNode(ASTExclusiveOrCondition.jjtCreate("ExclusiveOrCondition"));
}
 AndCondition() (  <XOR> AndCondition() )*{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void AndCondition() /*#AndCondition(>1)*/ : {}
{
{
jjtree.openGTNode(ASTAndCondition.jjtCreate("AndCondition"));
}
 ComparisonCondition() (  <AND> ComparisonCondition() )*{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void ComparisonCondition() /*#ComparisonCondition(>1)*/ :
{
Token t;
}
{
{
jjtree.openGTNode(ASTComparisonCondition.jjtCreate("ComparisonCondition"));
}
 AdditiveExpression() (  (  <EQ> |  <EQ2> |  <NE> |  <NE2> |  <LT> |  <GT> |  <LE> |  <GE>  ) { try {
ASTComparisonCondition jjtThis = (ASTComparisonCondition)jjtree.currentNode();
t = getToken(0);
            jjtThis.setName(t.image);
} finally {
}
}
 AdditiveExpression() )?{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void AdditiveExpression() /*#AdditiveExpression(>1)*/ :
{
Token t;
}
{
{
jjtree.openGTNode(ASTAdditiveExpression.jjtCreate("AdditiveExpression"));
}
 MultiplicativeExpression() (  (  <PLUS> |  <MINUS>  ) { try {
ASTAdditiveExpression jjtThis = (ASTAdditiveExpression)jjtree.currentNode();
t = getToken(0);
            jjtThis.setName(t.image);
} finally {
}
}
 MultiplicativeExpression() )?{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void MultiplicativeExpression() /*#MultiplicativeExpression(>1)*/ :
{
Token t;
}
{
{
jjtree.openGTNode(ASTMultiplicativeExpression.jjtCreate("MultiplicativeExpression"));
}
 UnarySignExpression() (  (  <TIMES> |  <DIVIDE> |  <REM>  ) { try {
ASTMultiplicativeExpression jjtThis = (ASTMultiplicativeExpression)jjtree.currentNode();
t = getToken(0);
            jjtThis.setName(t.image);
} finally {
}
}
 UnarySignExpression() )?{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void UnarySignExpression() /*#void*/ :
{
Token t;
}
{
 ( ( {
jjtree.openIndefiniteNode(ASTUnarySignExpression.jjtCreate("UnarySignExpression"));
}
 (  <PLUS> |  <MINUS>  ) { try {
ASTUnarySignExpression jjtThis = (ASTUnarySignExpression)jjtree.currentNode();
t = getToken(0);
            jjtThis.setName(t.image);
} finally {
}
}
 UnaryNotCondition(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 ) /*#UnarySignExpression*/ )
|  UnaryNotCondition()

}

void UnaryNotCondition() /*#void*/ :
{
Token t;
}
{
 ( ( {
jjtree.openIndefiniteNode(ASTUnaryNotCondition.jjtCreate("UnaryNotCondition"));
}
 (  <TILDE> |  <BANG>  ) { try {
ASTUnaryNotCondition jjtThis = (ASTUnaryNotCondition)jjtree.currentNode();
t = getToken(0);
            jjtThis.setName(t.image);
} finally {
}
}
 PrimaryPrefix(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 ) /*#UnaryNotCondition*/ )
|  PrimaryPrefix()

}

void PrimaryPrefix() /*#void*/ :
{
Token t;
}
{
 Literal()
|  MessageSequence()
|  <LPAREN> Condition() <RPAREN>

}

// **********************************************************

void MessageSequence() /*#MessageSequence(>1)*/ : {}
{
{
jjtree.openGTNode(ASTMessageSequence.jjtCreate("MessageSequence"));
}
 Name() (  Message() )*{
jjtree.closeGTNode(1);
jjtree.updateCurrentNode(1);
}

}

void Name() /*#void*/ :
{
Token t;
}
{
 ( ( {
jjtree.openIndefiniteNode(ASTName.jjtCreate("Name"));
}
 t=<IDENTIFIER> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTName jjtThis = (ASTName)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}
 ) /*#Name*/ )
|  UnboundName()
|  UnboundIndex()

}

void UnboundName() /*#UnboundName*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTUnboundName.jjtCreate("UnboundName"));
}
 <COLON> t=<IDENTIFIER> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTUnboundName jjtThis = (ASTUnboundName)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}

}

void UnboundIndex() /*#UnboundIndex*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTUnboundIndex.jjtCreate("UnboundIndex"));
}
 <DOLLAR> t=<INTEGER_LITERAL> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTUnboundIndex jjtThis = (ASTUnboundIndex)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}

}

void Message() /*#Message*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTMessage.jjtCreate("Message"));
}
 (  <DOT> |  <RARROW>  ) t=<IDENTIFIER> { try {
ASTMessage jjtThis = (ASTMessage)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
}
}
 (  Arguments() )?{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void Arguments() /*#Arguments*/ : {}
{
{
jjtree.openIndefiniteNode(ASTArguments.jjtCreate("Arguments"));
}
 <LPAREN> (  ArgumentList() )? <RPAREN>{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void ArgumentList() /*#ArgumentList*/ : {}
{
{
jjtree.openIndefiniteNode(ASTArgumentList.jjtCreate("ArgumentList"));
}
 Expression() (  <COMMA> Expression() )*{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void Literal() /*#void*/ :
{
Token t;
}
{
 ( ( {
jjtree.openIndefiniteNode(ASTIntegerLiteral.jjtCreate("IntegerLiteral"));
}
 t=<INTEGER_LITERAL> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTIntegerLiteral jjtThis = (ASTIntegerLiteral)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}
 ) /*#IntegerLiteral*/ )
|  ( ( {
jjtree.openIndefiniteNode(ASTFloatingPointLiteral.jjtCreate("FloatingPointLiteral"));
}
 t=<FLOATING_POINT_LITERAL> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTFloatingPointLiteral jjtThis = (ASTFloatingPointLiteral)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}
 ) /*#FloatingPointLiteral*/ )
|  ( ( {
jjtree.openIndefiniteNode(ASTStringLiteral.jjtCreate("StringLiteral"));
}
 t=<STRING_LITERAL2> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTStringLiteral jjtThis = (ASTStringLiteral)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}
 ) /*#StringLiteral*/ )
|  ( ( {
jjtree.openIndefiniteNode(ASTStringLiteral.jjtCreate("StringLiteral"));
}
 t=<STRING_LITERAL> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTStringLiteral jjtThis = (ASTStringLiteral)jjtree.currentNode();
jjtThis.setName(t.image);
} finally {
jjtree.updateCurrentNode(1);
}
}
 ) /*#StringLiteral*/ )
|  BooleanLiteral()
|  NullLiteral()

}

void BooleanLiteral() /*#BooleanLiteralClass*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTBooleanLiteralClass.jjtCreate("BooleanLiteralClass"));
}
 t=<TRUE> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTBooleanLiteralClass jjtThis = (ASTBooleanLiteralClass)jjtree.currentNode();
jjtThis.makeTrue();
} finally {
jjtree.updateCurrentNode(1);
}
}

| {
jjtree.openIndefiniteNode(ASTBooleanLiteralClass.jjtCreate("BooleanLiteralClass"));
}
 t=<FALSE> {
jjtree.closeIndefiniteNode();
}
{ try {
ASTBooleanLiteralClass jjtThis = (ASTBooleanLiteralClass)jjtree.currentNode();
jjtThis.makeFalse();
} finally {
jjtree.updateCurrentNode(1);
}
}


}

void NullLiteral() /*#NullLiteralClass*/ : {}
{
{
jjtree.openIndefiniteNode(ASTNullLiteralClass.jjtCreate("NullLiteralClass"));
}
 <NULL>{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

